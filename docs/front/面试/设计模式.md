# 设计模式

[JavaScript中常用的设计模式](https://segmentfault.com/a/1190000017787537)

## 工厂模式

```js
function createPerson(name, age, job) { 
 let o = new Object(); 
 o.name = name; 
 o.age = age; 
 o.job = job; 
 o.sayName = function() { 
 console.log(this.name); 
 }; 
 return o; 
} 
let person1 = createPerson("Nicholas", 29, "Software Engineer"); 
let person2 = createPerson("Greg", 27, "Doctor");
```

工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题题（即新创建的对象是什么类型）

## 构造函数模式

```js
function Person(name, age, job){ 
 this.name = name; 
 this.age = age; 
 this.job = job; 
 this.sayName = function() { 
 console.log(this.name); 
 }; 
} 
let person1 = new Person("Nicholas", 29, "Software Engineer"); 
let person2 = new Person("Greg", 27, "Doctor"); 
person1.sayName(); // Nicholas 
person2.sayName(); // Greg
```

在这个例子中，`Person()`构造函数代替了 `createPerson()`工厂函数。实际上，`Person()`内部的代码跟 `createPerson()`基本是一样的，只是有如下区别。

- 没有显式地创建对象。

- 属性和方法直接赋值给了 this。

- 没有 return



要创建 Person 的实例，应使用 new 操作符。以这种方式调用构造函数会执行如下操作。

(1) 在内存中创建一个新对象。

(2) 这个新对象内部的`[[Prototype]]`特性被赋值为构造函数的 prototype 属性。

(3) 构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）

(4) 执行构造函数内部的代码（给新对象添加属性）。

(5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。



1. **构造函数也是函数**, 与普通函数唯一的区别就是调用方式不同

2. 构造函数的问题

​	构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍. 即每次new都会创造自己的Function

 但是, 如果把函数定义在构造函数外, 样虽然解决了相同逻辑的函数重复定义的问题，但全局作用域也因此被搞乱了，因为那个函数实际上只能在一个对象上调用。如果这个对象需要多个方法，那么就要在全局作用域中定义多个函数. 这个新问题可以通过**原型模式**来解决。

## 原型模式

每个函数都会创建一个 `prototype` 属性，这个属性是一个**对象**，包含应该由**特定引用类型 (函数/对象) 的实例共享的属性和方法**. 这个对象就是通过**调用构造函数创建的对象的原型**

```js
// 所以, 就是把要共享的 函数\属性 挂载到公共的
function Person() {} 
Person.prototype.name = "Nicholas"; 
Person.prototype.age = 29; 
Person.prototype.job = "Software Engineer"; 
Person.prototype.sayName = function() { 
 console.log(this.name); 
}; 
let person1 = new Person(); 
person1.sayName(); // "Nicholas" 
let person2 = new Person(); 
person2.sayName(); // "Nicholas" 
console.log(person1.sayName == person2.sayName); // true
```

与构造函数模式不同，使用这种原型模式定义的属性和方法是由所有实例共享的。




- 策略模式
- 组合模式
- 
- 单例模式
- 观察者模式(发布-订阅模式)